# This script is used to generate the ConfigData struct for holding gosible base config definitions,
# as well as golang parser for a yaml file containing base config definitions.

# The 'base.yml' file is copied from Ansible and it contains defaults & type information for many
# of config options used by Ansible.
from __future__ import annotations

import sys

import yaml
from pathlib import Path
from typing import Any, Optional
from contextlib import redirect_stdout
from collections import defaultdict

WORKDIR = Path(__file__).parent.parent
PATH_TO_BASE_DEFS_FILE = WORKDIR / "base.yml"

KNOWN_FIELD_TYPES = {
    # Types for some of the fields that do not have type/default/choices information
    # and because of that cannot be autogenerated.
    "CACHE_PLUGIN_CONNECTION": "string",
    "DEFAULT_BECOME_EXE": "string",
    "DEFAULT_BECOME_FLAGS": "string",
    "DEFAULT_JINJA2_EXTENSIONS": "[]string",  # TODO this one is questionable
    "DEFAULT_MODULE_ARGS": "string",  # TODO verify
    "DEFAULT_REMOTE_USER": "string",
    "DEFAULT_VAULT_ENCRYPT_IDENTITY": "string",  # TODO verify
    "CONNECTION_FACTS_MODULES": "map[string]string",
    "INVENTORY_CACHE_PLUGIN": "string",  # TODO verify
    "INVENTORY_CACHE_PLUGIN_CONNECTION": "string",
    "NETCONF_SSH_CONFIG": "string",
}

IGNORED_FIELDS = [
    "INTERPRETER_PYTHON_DISTRO_MAP",
    "INVENTORY_IGNORE_EXTS",  # TODO It should not be ignored, but it's a template string...
    "MODULE_IGNORE_EXTS",  # TODO again, template string
    "PLUGIN_FILTERS_CFG",  # TODO fix, has stupin 'none' default value
    "CONNECTION_FACTS_MODULES",  # TODO it's a map, harder to parse, support will be added when needed
    # We don't support cowsay.
    "ANSIBLE_COW_SELECTION",
    "GALAXY_REQUIRED_VALID_SIGNATURE_COUNT",  # Type declared and type of default conflict; we don't support galaxy anyways
]

TO_GOLANG_TYPE = {
    "string": "string",
    "integer": "int",
    "int": "int",
    "float": "float64",
    "boolean": "bool",
    "bool": "bool",
    "path": "string",
    "pathspec": "string",
    "str": "string",
    "pathlist": "string",
    "tmppath": "string",
    "none": "string",  # TODO special case for DEFAULT_NULL_REPRESENTATION - determine the right type in the future
}

GOLANG_TYPE_TO_INI_FN = {
    "int": "Int()",
    "string": "String()",
    "[]string": 'Strings(",")',
    "bool": "Bool()",
    "float64": "Float64()",
}

SAFE_INI_TYPE_CONVERSIONS = ["string", "[]string"]


def format_field_for_struct(key: str, value: dict[str, Any]) -> str:
    field_type = translate_type_to_golang(key, value)

    name = value.get("name")
    description = value.get("description")
    if isinstance(description, list):
        description = "\n\t//\t".join(description)
    if description and "TODO: write it" in description:
        description = None
    version_added = value.get("version_added")

    formatted_name = "" if name is None else "// Name: {}".format(name)
    formatted_description = (
        "" if description is None else "// Description:\n\t//\t{}".format(description)
    )
    formatted_version = (
        "" if version_added is None else "// Version added: {}".format(version_added)
    )

    formatted_fname_and_type = "{} {}".format(key, field_type)
    return "\n".join(
        "\t" + p
        for p in [
            formatted_name,
            formatted_description,
            formatted_version,
            formatted_fname_and_type,
        ]
        if p
    )


def try_deduct_type(value: Any) -> Optional[str]:
    if value.__class__ in [str, int, float, bool]:
        return TO_GOLANG_TYPE[value.__class__.__name__]

    if isinstance(value, list):
        if value:
            if isinstance(value[0], str):
                return "[]string"

    return None


def translate_type_to_golang(key: str, value: dict[str, Any]) -> Optional[str]:
    suggested_type = value.get("type")

    if suggested_type is None:
        default = value.get("default")
        if default is None and "choices" in value:
            default = value["choices"]
        deduced = try_deduct_type(default)
        if deduced:
            return deduced
        return KNOWN_FIELD_TYPES.get(key)

    if suggested_type in TO_GOLANG_TYPE:
        return TO_GOLANG_TYPE[suggested_type]

    if suggested_type == "list":
        # TODO it assumes all lists are lists of strings, which certainly is not true
        # will need to be changed in the future
        return "[]string"

    if key in KNOWN_FIELD_TYPES:
        return KNOWN_FIELD_TYPES[key]

    raise Exception("unknown type: {} for key {}".format(suggested_type, key))


TypeAndValues = tuple[str, dict[str, Any]]
KeyTypeIniData = list[tuple[str, str, dict[str, Any]]]


def generate_config_struct() -> dict[str, TypeAndValues]:
    with open(PATH_TO_BASE_DEFS_FILE, "r") as f:
        base_defs = yaml.load(f, Loader=yaml.Loader)

    kv_pairs = [(k, v) for (k, v) in base_defs.items()]
    kv_pairs.sort(key=lambda p: p[0])
    key_types = {}

    # Generate the ConfigData struct
    print(FILE_AND_STRUCT_HEADER)
    for key, value in kv_pairs:
        if key in IGNORED_FIELDS:
            print("Ignoring key", key, file=sys.stderr)
            key_types[key] = (None, value)
            continue
        field_type = translate_type_to_golang(key, value)
        if field_type:
            print(format_field_for_struct(key, value), end="\n\n")
            key_types[key] = (field_type, value)
        else:
            print(
                "Failed to determine type for field: {}\nValue: {}\n".format(
                    key, value
                ),
                file=sys.stderr,
            )

    print("}")

    return key_types


FILE_AND_STRUCT_HEADER = """
// This file is generated by base_defs_parser_generator.py, do not modify it manually!

package config

import (
	"fmt"
	"gopkg.in/ini.v1"
	"gopkg.in/yaml.v2"
	"strings"
)

// ConfigData holds the parsed base config definitions
type ConfigData struct {
"""

PARSE_CONFIG_DATA_FUNCTION = """
// ParseBaseDefsConfigData parses the base config definitions from a yaml file
func ParseBaseDefsConfigData(fileContents []byte) (*ConfigData, error) {
	var data map[string]map[string]interface{}
	err := yaml.Unmarshal(fileContents, &data)
	if err != nil {
		return nil, err
	}

	var configData ConfigData
	for key, value := range data {
		err := parseField(&configData, key, value)
		if err != nil {
			return nil, err
		}
	}

	return &configData, nil
}
"""

PARSE_FIELD_FUNCTION_HEAD = """
func parseField(data *ConfigData, key string, value map[string]interface{}) error {
	defaultValue, ok := value["default"]
	if !ok {
		defaultValue, ok = value["choices"]
		if !ok {
			// No default or choices, so we can't parse this, but it's not an error.
			return nil
		}
	}

	if defaultValue == nil {
   	    // Not an error, but the parsing logic below doesn't handle nil values.
    	return nil
    }

	switch key {
"""

PARSE_FIELD_FUNCTION_TAIL = """
	default:
		return fmt.Errorf("unrecognized config key: %s", key)
	}

	if !ok {
		return fmt.Errorf("unable to parse config field: %s, value: %s", key, defaultValue)
	}
	return nil
}
"""


def generate_parser(items_with_types: dict[str, TypeAndValues]) -> None:
    print(PARSE_CONFIG_DATA_FUNCTION)
    print(PARSE_FIELD_FUNCTION_HEAD)

    for key, (type_, _) in items_with_types.items():
        if key in IGNORED_FIELDS:
            continue

        if type_.startswith("[]"):
            if type_ == "[]string":
                string_case = f"""case string: data.{key} = strings.Split(v, ", ")"""
            else:
                string_case = ""
            print(
                f"""\tcase \"{key}\":
        switch v := defaultValue.(type) {{
        case {type_}:
            data.{key} = v
        case []interface{{}}:
			data.{key} = []string{{}}
			for _, value := range v {{
				switch value.(type) {{
				case {type_[2:]}:
					data.{key} = append(data.{key}, value.(string))
				default:
					ok = false
					break
				}}
			}}
		{string_case}
        default:
            ok = false
        }}
            """
            )
        else:
            print(
                '	case "{key}":\n'
                "		data.{key}, ok = defaultValue.({type_})".format(
                    key=key, type_=type_
                ),
            )

    print()

    for key in IGNORED_FIELDS:
        print(f'	case "{key}":\n' "		return nil  // Ignored field.")

    print(PARSE_FIELD_FUNCTION_TAIL)


INI_PARSER_FUNCTION_HEAD = """

func (d *ConfigData) updateFieldFromIni(section string, key *ini.Key) error {"""

INI_PARSER_FUNCTION_TAIL = """
return err
}
"""


def partition_items_by_ini_section(
    items_with_types: dict[str, TypeAndValues]
) -> dict[str, KeyTypeIniData]:
    keys_by_section = defaultdict(list)
    for k, v in items_with_types.items():
        ini_datas = v[1].get("ini", [])
        if not ini_datas:
            continue

        if len(ini_datas) > 1:
            print("Key", k, "has more than 1 entry in ini list", file=sys.stderr)

        for ini_data in ini_datas:
            keys_by_section[ini_data["section"]].append((k, v[0], ini_data))

    return keys_by_section


def generate_section_switch_body(items: KeyTypeIniData) -> None:
    print("switch key.Name() {")
    for (yaml_key, go_type, ini_data) in items:
        name = ini_data["key"]
        print(f'case "{name}":')
        if yaml_key in IGNORED_FIELDS:
            print("// Ignored field.")
            continue

        ini_to_native_fn_call = GOLANG_TYPE_TO_INI_FN[go_type]
        if go_type in SAFE_INI_TYPE_CONVERSIONS:
            print(f"d.{yaml_key} = key.{ini_to_native_fn_call}")
        else:
            print(f"d.{yaml_key}, err = key.{ini_to_native_fn_call}")

    print(
        'default:\nreturn fmt.Errorf("unrecognized key %s in section %s", key.Name(), section)'
    )
    print("}")


def generate_ini_parser(items_with_types: dict[str, TypeAndValues]) -> None:
    print(INI_PARSER_FUNCTION_HEAD)
    keys_by_section = partition_items_by_ini_section(items_with_types)

    print("var err error")
    print("switch section {")
    for section, items in keys_by_section.items():
        print(f'case "{section}":')
        generate_section_switch_body(items)

    print('default:\nreturn fmt.Errorf("unrecognized section %s", section)')
    print("}")

    print(INI_PARSER_FUNCTION_TAIL)


def regenerate_defs() -> None:
    items_with_types = generate_config_struct()
    generate_parser(items_with_types)
    generate_ini_parser(items_with_types)


if __name__ == "__main__":
    with open(WORKDIR / "config_data.go", "w+") as f:
        with redirect_stdout(f):
            regenerate_defs()
else:
    print("This file should not be imported from other files.", file=sys.stderr)
    exit(1)
